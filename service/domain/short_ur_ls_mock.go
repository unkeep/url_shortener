package domain

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ShortURLsMock implements ShortURLs
type ShortURLsMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, originURL string) (shortURL string, err error)
	inspectFuncCreate   func(ctx context.Context, originURL string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mShortURLsMockCreate

	funcDelete          func(ctx context.Context, shortURL string) (err error)
	inspectFuncDelete   func(ctx context.Context, shortURL string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mShortURLsMockDelete

	funcDeleteByOriginURL          func(ctx context.Context, originURL string) (err error)
	inspectFuncDeleteByOriginURL   func(ctx context.Context, originURL string)
	afterDeleteByOriginURLCounter  uint64
	beforeDeleteByOriginURLCounter uint64
	DeleteByOriginURLMock          mShortURLsMockDeleteByOriginURL

	funcGetByOriginURL          func(ctx context.Context, originURL string) (shortURL string, err error)
	inspectFuncGetByOriginURL   func(ctx context.Context, originURL string)
	afterGetByOriginURLCounter  uint64
	beforeGetByOriginURLCounter uint64
	GetByOriginURLMock          mShortURLsMockGetByOriginURL

	funcGetOriginURLByShortPath          func(ctx context.Context, shortURLPath string) (originURL string, err error)
	inspectFuncGetOriginURLByShortPath   func(ctx context.Context, shortURLPath string)
	afterGetOriginURLByShortPathCounter  uint64
	beforeGetOriginURLByShortPathCounter uint64
	GetOriginURLByShortPathMock          mShortURLsMockGetOriginURLByShortPath
}

// NewShortURLsMock returns a mock for ShortURLs
func NewShortURLsMock(t minimock.Tester) *ShortURLsMock {
	m := &ShortURLsMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mShortURLsMockCreate{mock: m}
	m.CreateMock.callArgs = []*ShortURLsMockCreateParams{}

	m.DeleteMock = mShortURLsMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ShortURLsMockDeleteParams{}

	m.DeleteByOriginURLMock = mShortURLsMockDeleteByOriginURL{mock: m}
	m.DeleteByOriginURLMock.callArgs = []*ShortURLsMockDeleteByOriginURLParams{}

	m.GetByOriginURLMock = mShortURLsMockGetByOriginURL{mock: m}
	m.GetByOriginURLMock.callArgs = []*ShortURLsMockGetByOriginURLParams{}

	m.GetOriginURLByShortPathMock = mShortURLsMockGetOriginURLByShortPath{mock: m}
	m.GetOriginURLByShortPathMock.callArgs = []*ShortURLsMockGetOriginURLByShortPathParams{}

	return m
}

type mShortURLsMockCreate struct {
	mock               *ShortURLsMock
	defaultExpectation *ShortURLsMockCreateExpectation
	expectations       []*ShortURLsMockCreateExpectation

	callArgs []*ShortURLsMockCreateParams
	mutex    sync.RWMutex
}

// ShortURLsMockCreateExpectation specifies expectation struct of the ShortURLs.Create
type ShortURLsMockCreateExpectation struct {
	mock    *ShortURLsMock
	params  *ShortURLsMockCreateParams
	results *ShortURLsMockCreateResults
	Counter uint64
}

// ShortURLsMockCreateParams contains parameters of the ShortURLs.Create
type ShortURLsMockCreateParams struct {
	ctx       context.Context
	originURL string
}

// ShortURLsMockCreateResults contains results of the ShortURLs.Create
type ShortURLsMockCreateResults struct {
	shortURL string
	err      error
}

// Expect sets up expected params for ShortURLs.Create
func (mmCreate *mShortURLsMockCreate) Expect(ctx context.Context, originURL string) *mShortURLsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ShortURLsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ShortURLsMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ShortURLsMockCreateParams{ctx, originURL}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ShortURLs.Create
func (mmCreate *mShortURLsMockCreate) Inspect(f func(ctx context.Context, originURL string)) *mShortURLsMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ShortURLsMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ShortURLs.Create
func (mmCreate *mShortURLsMockCreate) Return(shortURL string, err error) *ShortURLsMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ShortURLsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ShortURLsMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ShortURLsMockCreateResults{shortURL, err}
	return mmCreate.mock
}

//Set uses given function f to mock the ShortURLs.Create method
func (mmCreate *mShortURLsMockCreate) Set(f func(ctx context.Context, originURL string) (shortURL string, err error)) *ShortURLsMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ShortURLs.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ShortURLs.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ShortURLs.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mShortURLsMockCreate) When(ctx context.Context, originURL string) *ShortURLsMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ShortURLsMock.Create mock is already set by Set")
	}

	expectation := &ShortURLsMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ShortURLsMockCreateParams{ctx, originURL},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ShortURLs.Create return parameters for the expectation previously defined by the When method
func (e *ShortURLsMockCreateExpectation) Then(shortURL string, err error) *ShortURLsMock {
	e.results = &ShortURLsMockCreateResults{shortURL, err}
	return e.mock
}

// Create implements ShortURLs
func (mmCreate *ShortURLsMock) Create(ctx context.Context, originURL string) (shortURL string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, originURL)
	}

	mm_params := &ShortURLsMockCreateParams{ctx, originURL}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.shortURL, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ShortURLsMockCreateParams{ctx, originURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ShortURLsMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ShortURLsMock.Create")
		}
		return (*mm_results).shortURL, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, originURL)
	}
	mmCreate.t.Fatalf("Unexpected call to ShortURLsMock.Create. %v %v", ctx, originURL)
	return
}

// CreateAfterCounter returns a count of finished ShortURLsMock.Create invocations
func (mmCreate *ShortURLsMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ShortURLsMock.Create invocations
func (mmCreate *ShortURLsMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ShortURLsMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mShortURLsMockCreate) Calls() []*ShortURLsMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ShortURLsMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ShortURLsMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ShortURLsMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShortURLsMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShortURLsMock.Create")
		} else {
			m.t.Errorf("Expected call to ShortURLsMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ShortURLsMock.Create")
	}
}

type mShortURLsMockDelete struct {
	mock               *ShortURLsMock
	defaultExpectation *ShortURLsMockDeleteExpectation
	expectations       []*ShortURLsMockDeleteExpectation

	callArgs []*ShortURLsMockDeleteParams
	mutex    sync.RWMutex
}

// ShortURLsMockDeleteExpectation specifies expectation struct of the ShortURLs.Delete
type ShortURLsMockDeleteExpectation struct {
	mock    *ShortURLsMock
	params  *ShortURLsMockDeleteParams
	results *ShortURLsMockDeleteResults
	Counter uint64
}

// ShortURLsMockDeleteParams contains parameters of the ShortURLs.Delete
type ShortURLsMockDeleteParams struct {
	ctx      context.Context
	shortURL string
}

// ShortURLsMockDeleteResults contains results of the ShortURLs.Delete
type ShortURLsMockDeleteResults struct {
	err error
}

// Expect sets up expected params for ShortURLs.Delete
func (mmDelete *mShortURLsMockDelete) Expect(ctx context.Context, shortURL string) *mShortURLsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ShortURLsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ShortURLsMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ShortURLsMockDeleteParams{ctx, shortURL}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ShortURLs.Delete
func (mmDelete *mShortURLsMockDelete) Inspect(f func(ctx context.Context, shortURL string)) *mShortURLsMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ShortURLsMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ShortURLs.Delete
func (mmDelete *mShortURLsMockDelete) Return(err error) *ShortURLsMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ShortURLsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ShortURLsMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ShortURLsMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the ShortURLs.Delete method
func (mmDelete *mShortURLsMockDelete) Set(f func(ctx context.Context, shortURL string) (err error)) *ShortURLsMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ShortURLs.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ShortURLs.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ShortURLs.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mShortURLsMockDelete) When(ctx context.Context, shortURL string) *ShortURLsMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ShortURLsMock.Delete mock is already set by Set")
	}

	expectation := &ShortURLsMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ShortURLsMockDeleteParams{ctx, shortURL},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ShortURLs.Delete return parameters for the expectation previously defined by the When method
func (e *ShortURLsMockDeleteExpectation) Then(err error) *ShortURLsMock {
	e.results = &ShortURLsMockDeleteResults{err}
	return e.mock
}

// Delete implements ShortURLs
func (mmDelete *ShortURLsMock) Delete(ctx context.Context, shortURL string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, shortURL)
	}

	mm_params := &ShortURLsMockDeleteParams{ctx, shortURL}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ShortURLsMockDeleteParams{ctx, shortURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ShortURLsMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ShortURLsMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, shortURL)
	}
	mmDelete.t.Fatalf("Unexpected call to ShortURLsMock.Delete. %v %v", ctx, shortURL)
	return
}

// DeleteAfterCounter returns a count of finished ShortURLsMock.Delete invocations
func (mmDelete *ShortURLsMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ShortURLsMock.Delete invocations
func (mmDelete *ShortURLsMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ShortURLsMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mShortURLsMockDelete) Calls() []*ShortURLsMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ShortURLsMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ShortURLsMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ShortURLsMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShortURLsMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShortURLsMock.Delete")
		} else {
			m.t.Errorf("Expected call to ShortURLsMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ShortURLsMock.Delete")
	}
}

type mShortURLsMockDeleteByOriginURL struct {
	mock               *ShortURLsMock
	defaultExpectation *ShortURLsMockDeleteByOriginURLExpectation
	expectations       []*ShortURLsMockDeleteByOriginURLExpectation

	callArgs []*ShortURLsMockDeleteByOriginURLParams
	mutex    sync.RWMutex
}

// ShortURLsMockDeleteByOriginURLExpectation specifies expectation struct of the ShortURLs.DeleteByOriginURL
type ShortURLsMockDeleteByOriginURLExpectation struct {
	mock    *ShortURLsMock
	params  *ShortURLsMockDeleteByOriginURLParams
	results *ShortURLsMockDeleteByOriginURLResults
	Counter uint64
}

// ShortURLsMockDeleteByOriginURLParams contains parameters of the ShortURLs.DeleteByOriginURL
type ShortURLsMockDeleteByOriginURLParams struct {
	ctx       context.Context
	originURL string
}

// ShortURLsMockDeleteByOriginURLResults contains results of the ShortURLs.DeleteByOriginURL
type ShortURLsMockDeleteByOriginURLResults struct {
	err error
}

// Expect sets up expected params for ShortURLs.DeleteByOriginURL
func (mmDeleteByOriginURL *mShortURLsMockDeleteByOriginURL) Expect(ctx context.Context, originURL string) *mShortURLsMockDeleteByOriginURL {
	if mmDeleteByOriginURL.mock.funcDeleteByOriginURL != nil {
		mmDeleteByOriginURL.mock.t.Fatalf("ShortURLsMock.DeleteByOriginURL mock is already set by Set")
	}

	if mmDeleteByOriginURL.defaultExpectation == nil {
		mmDeleteByOriginURL.defaultExpectation = &ShortURLsMockDeleteByOriginURLExpectation{}
	}

	mmDeleteByOriginURL.defaultExpectation.params = &ShortURLsMockDeleteByOriginURLParams{ctx, originURL}
	for _, e := range mmDeleteByOriginURL.expectations {
		if minimock.Equal(e.params, mmDeleteByOriginURL.defaultExpectation.params) {
			mmDeleteByOriginURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteByOriginURL.defaultExpectation.params)
		}
	}

	return mmDeleteByOriginURL
}

// Inspect accepts an inspector function that has same arguments as the ShortURLs.DeleteByOriginURL
func (mmDeleteByOriginURL *mShortURLsMockDeleteByOriginURL) Inspect(f func(ctx context.Context, originURL string)) *mShortURLsMockDeleteByOriginURL {
	if mmDeleteByOriginURL.mock.inspectFuncDeleteByOriginURL != nil {
		mmDeleteByOriginURL.mock.t.Fatalf("Inspect function is already set for ShortURLsMock.DeleteByOriginURL")
	}

	mmDeleteByOriginURL.mock.inspectFuncDeleteByOriginURL = f

	return mmDeleteByOriginURL
}

// Return sets up results that will be returned by ShortURLs.DeleteByOriginURL
func (mmDeleteByOriginURL *mShortURLsMockDeleteByOriginURL) Return(err error) *ShortURLsMock {
	if mmDeleteByOriginURL.mock.funcDeleteByOriginURL != nil {
		mmDeleteByOriginURL.mock.t.Fatalf("ShortURLsMock.DeleteByOriginURL mock is already set by Set")
	}

	if mmDeleteByOriginURL.defaultExpectation == nil {
		mmDeleteByOriginURL.defaultExpectation = &ShortURLsMockDeleteByOriginURLExpectation{mock: mmDeleteByOriginURL.mock}
	}
	mmDeleteByOriginURL.defaultExpectation.results = &ShortURLsMockDeleteByOriginURLResults{err}
	return mmDeleteByOriginURL.mock
}

//Set uses given function f to mock the ShortURLs.DeleteByOriginURL method
func (mmDeleteByOriginURL *mShortURLsMockDeleteByOriginURL) Set(f func(ctx context.Context, originURL string) (err error)) *ShortURLsMock {
	if mmDeleteByOriginURL.defaultExpectation != nil {
		mmDeleteByOriginURL.mock.t.Fatalf("Default expectation is already set for the ShortURLs.DeleteByOriginURL method")
	}

	if len(mmDeleteByOriginURL.expectations) > 0 {
		mmDeleteByOriginURL.mock.t.Fatalf("Some expectations are already set for the ShortURLs.DeleteByOriginURL method")
	}

	mmDeleteByOriginURL.mock.funcDeleteByOriginURL = f
	return mmDeleteByOriginURL.mock
}

// When sets expectation for the ShortURLs.DeleteByOriginURL which will trigger the result defined by the following
// Then helper
func (mmDeleteByOriginURL *mShortURLsMockDeleteByOriginURL) When(ctx context.Context, originURL string) *ShortURLsMockDeleteByOriginURLExpectation {
	if mmDeleteByOriginURL.mock.funcDeleteByOriginURL != nil {
		mmDeleteByOriginURL.mock.t.Fatalf("ShortURLsMock.DeleteByOriginURL mock is already set by Set")
	}

	expectation := &ShortURLsMockDeleteByOriginURLExpectation{
		mock:   mmDeleteByOriginURL.mock,
		params: &ShortURLsMockDeleteByOriginURLParams{ctx, originURL},
	}
	mmDeleteByOriginURL.expectations = append(mmDeleteByOriginURL.expectations, expectation)
	return expectation
}

// Then sets up ShortURLs.DeleteByOriginURL return parameters for the expectation previously defined by the When method
func (e *ShortURLsMockDeleteByOriginURLExpectation) Then(err error) *ShortURLsMock {
	e.results = &ShortURLsMockDeleteByOriginURLResults{err}
	return e.mock
}

// DeleteByOriginURL implements ShortURLs
func (mmDeleteByOriginURL *ShortURLsMock) DeleteByOriginURL(ctx context.Context, originURL string) (err error) {
	mm_atomic.AddUint64(&mmDeleteByOriginURL.beforeDeleteByOriginURLCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteByOriginURL.afterDeleteByOriginURLCounter, 1)

	if mmDeleteByOriginURL.inspectFuncDeleteByOriginURL != nil {
		mmDeleteByOriginURL.inspectFuncDeleteByOriginURL(ctx, originURL)
	}

	mm_params := &ShortURLsMockDeleteByOriginURLParams{ctx, originURL}

	// Record call args
	mmDeleteByOriginURL.DeleteByOriginURLMock.mutex.Lock()
	mmDeleteByOriginURL.DeleteByOriginURLMock.callArgs = append(mmDeleteByOriginURL.DeleteByOriginURLMock.callArgs, mm_params)
	mmDeleteByOriginURL.DeleteByOriginURLMock.mutex.Unlock()

	for _, e := range mmDeleteByOriginURL.DeleteByOriginURLMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteByOriginURL.DeleteByOriginURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteByOriginURL.DeleteByOriginURLMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteByOriginURL.DeleteByOriginURLMock.defaultExpectation.params
		mm_got := ShortURLsMockDeleteByOriginURLParams{ctx, originURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteByOriginURL.t.Errorf("ShortURLsMock.DeleteByOriginURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteByOriginURL.DeleteByOriginURLMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteByOriginURL.t.Fatal("No results are set for the ShortURLsMock.DeleteByOriginURL")
		}
		return (*mm_results).err
	}
	if mmDeleteByOriginURL.funcDeleteByOriginURL != nil {
		return mmDeleteByOriginURL.funcDeleteByOriginURL(ctx, originURL)
	}
	mmDeleteByOriginURL.t.Fatalf("Unexpected call to ShortURLsMock.DeleteByOriginURL. %v %v", ctx, originURL)
	return
}

// DeleteByOriginURLAfterCounter returns a count of finished ShortURLsMock.DeleteByOriginURL invocations
func (mmDeleteByOriginURL *ShortURLsMock) DeleteByOriginURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByOriginURL.afterDeleteByOriginURLCounter)
}

// DeleteByOriginURLBeforeCounter returns a count of ShortURLsMock.DeleteByOriginURL invocations
func (mmDeleteByOriginURL *ShortURLsMock) DeleteByOriginURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByOriginURL.beforeDeleteByOriginURLCounter)
}

// Calls returns a list of arguments used in each call to ShortURLsMock.DeleteByOriginURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteByOriginURL *mShortURLsMockDeleteByOriginURL) Calls() []*ShortURLsMockDeleteByOriginURLParams {
	mmDeleteByOriginURL.mutex.RLock()

	argCopy := make([]*ShortURLsMockDeleteByOriginURLParams, len(mmDeleteByOriginURL.callArgs))
	copy(argCopy, mmDeleteByOriginURL.callArgs)

	mmDeleteByOriginURL.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteByOriginURLDone returns true if the count of the DeleteByOriginURL invocations corresponds
// the number of defined expectations
func (m *ShortURLsMock) MinimockDeleteByOriginURLDone() bool {
	for _, e := range m.DeleteByOriginURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByOriginURLMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByOriginURLCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByOriginURL != nil && mm_atomic.LoadUint64(&m.afterDeleteByOriginURLCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteByOriginURLInspect logs each unmet expectation
func (m *ShortURLsMock) MinimockDeleteByOriginURLInspect() {
	for _, e := range m.DeleteByOriginURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShortURLsMock.DeleteByOriginURL with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByOriginURLMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByOriginURLCounter) < 1 {
		if m.DeleteByOriginURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShortURLsMock.DeleteByOriginURL")
		} else {
			m.t.Errorf("Expected call to ShortURLsMock.DeleteByOriginURL with params: %#v", *m.DeleteByOriginURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByOriginURL != nil && mm_atomic.LoadUint64(&m.afterDeleteByOriginURLCounter) < 1 {
		m.t.Error("Expected call to ShortURLsMock.DeleteByOriginURL")
	}
}

type mShortURLsMockGetByOriginURL struct {
	mock               *ShortURLsMock
	defaultExpectation *ShortURLsMockGetByOriginURLExpectation
	expectations       []*ShortURLsMockGetByOriginURLExpectation

	callArgs []*ShortURLsMockGetByOriginURLParams
	mutex    sync.RWMutex
}

// ShortURLsMockGetByOriginURLExpectation specifies expectation struct of the ShortURLs.GetByOriginURL
type ShortURLsMockGetByOriginURLExpectation struct {
	mock    *ShortURLsMock
	params  *ShortURLsMockGetByOriginURLParams
	results *ShortURLsMockGetByOriginURLResults
	Counter uint64
}

// ShortURLsMockGetByOriginURLParams contains parameters of the ShortURLs.GetByOriginURL
type ShortURLsMockGetByOriginURLParams struct {
	ctx       context.Context
	originURL string
}

// ShortURLsMockGetByOriginURLResults contains results of the ShortURLs.GetByOriginURL
type ShortURLsMockGetByOriginURLResults struct {
	shortURL string
	err      error
}

// Expect sets up expected params for ShortURLs.GetByOriginURL
func (mmGetByOriginURL *mShortURLsMockGetByOriginURL) Expect(ctx context.Context, originURL string) *mShortURLsMockGetByOriginURL {
	if mmGetByOriginURL.mock.funcGetByOriginURL != nil {
		mmGetByOriginURL.mock.t.Fatalf("ShortURLsMock.GetByOriginURL mock is already set by Set")
	}

	if mmGetByOriginURL.defaultExpectation == nil {
		mmGetByOriginURL.defaultExpectation = &ShortURLsMockGetByOriginURLExpectation{}
	}

	mmGetByOriginURL.defaultExpectation.params = &ShortURLsMockGetByOriginURLParams{ctx, originURL}
	for _, e := range mmGetByOriginURL.expectations {
		if minimock.Equal(e.params, mmGetByOriginURL.defaultExpectation.params) {
			mmGetByOriginURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOriginURL.defaultExpectation.params)
		}
	}

	return mmGetByOriginURL
}

// Inspect accepts an inspector function that has same arguments as the ShortURLs.GetByOriginURL
func (mmGetByOriginURL *mShortURLsMockGetByOriginURL) Inspect(f func(ctx context.Context, originURL string)) *mShortURLsMockGetByOriginURL {
	if mmGetByOriginURL.mock.inspectFuncGetByOriginURL != nil {
		mmGetByOriginURL.mock.t.Fatalf("Inspect function is already set for ShortURLsMock.GetByOriginURL")
	}

	mmGetByOriginURL.mock.inspectFuncGetByOriginURL = f

	return mmGetByOriginURL
}

// Return sets up results that will be returned by ShortURLs.GetByOriginURL
func (mmGetByOriginURL *mShortURLsMockGetByOriginURL) Return(shortURL string, err error) *ShortURLsMock {
	if mmGetByOriginURL.mock.funcGetByOriginURL != nil {
		mmGetByOriginURL.mock.t.Fatalf("ShortURLsMock.GetByOriginURL mock is already set by Set")
	}

	if mmGetByOriginURL.defaultExpectation == nil {
		mmGetByOriginURL.defaultExpectation = &ShortURLsMockGetByOriginURLExpectation{mock: mmGetByOriginURL.mock}
	}
	mmGetByOriginURL.defaultExpectation.results = &ShortURLsMockGetByOriginURLResults{shortURL, err}
	return mmGetByOriginURL.mock
}

//Set uses given function f to mock the ShortURLs.GetByOriginURL method
func (mmGetByOriginURL *mShortURLsMockGetByOriginURL) Set(f func(ctx context.Context, originURL string) (shortURL string, err error)) *ShortURLsMock {
	if mmGetByOriginURL.defaultExpectation != nil {
		mmGetByOriginURL.mock.t.Fatalf("Default expectation is already set for the ShortURLs.GetByOriginURL method")
	}

	if len(mmGetByOriginURL.expectations) > 0 {
		mmGetByOriginURL.mock.t.Fatalf("Some expectations are already set for the ShortURLs.GetByOriginURL method")
	}

	mmGetByOriginURL.mock.funcGetByOriginURL = f
	return mmGetByOriginURL.mock
}

// When sets expectation for the ShortURLs.GetByOriginURL which will trigger the result defined by the following
// Then helper
func (mmGetByOriginURL *mShortURLsMockGetByOriginURL) When(ctx context.Context, originURL string) *ShortURLsMockGetByOriginURLExpectation {
	if mmGetByOriginURL.mock.funcGetByOriginURL != nil {
		mmGetByOriginURL.mock.t.Fatalf("ShortURLsMock.GetByOriginURL mock is already set by Set")
	}

	expectation := &ShortURLsMockGetByOriginURLExpectation{
		mock:   mmGetByOriginURL.mock,
		params: &ShortURLsMockGetByOriginURLParams{ctx, originURL},
	}
	mmGetByOriginURL.expectations = append(mmGetByOriginURL.expectations, expectation)
	return expectation
}

// Then sets up ShortURLs.GetByOriginURL return parameters for the expectation previously defined by the When method
func (e *ShortURLsMockGetByOriginURLExpectation) Then(shortURL string, err error) *ShortURLsMock {
	e.results = &ShortURLsMockGetByOriginURLResults{shortURL, err}
	return e.mock
}

// GetByOriginURL implements ShortURLs
func (mmGetByOriginURL *ShortURLsMock) GetByOriginURL(ctx context.Context, originURL string) (shortURL string, err error) {
	mm_atomic.AddUint64(&mmGetByOriginURL.beforeGetByOriginURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOriginURL.afterGetByOriginURLCounter, 1)

	if mmGetByOriginURL.inspectFuncGetByOriginURL != nil {
		mmGetByOriginURL.inspectFuncGetByOriginURL(ctx, originURL)
	}

	mm_params := &ShortURLsMockGetByOriginURLParams{ctx, originURL}

	// Record call args
	mmGetByOriginURL.GetByOriginURLMock.mutex.Lock()
	mmGetByOriginURL.GetByOriginURLMock.callArgs = append(mmGetByOriginURL.GetByOriginURLMock.callArgs, mm_params)
	mmGetByOriginURL.GetByOriginURLMock.mutex.Unlock()

	for _, e := range mmGetByOriginURL.GetByOriginURLMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.shortURL, e.results.err
		}
	}

	if mmGetByOriginURL.GetByOriginURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOriginURL.GetByOriginURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOriginURL.GetByOriginURLMock.defaultExpectation.params
		mm_got := ShortURLsMockGetByOriginURLParams{ctx, originURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOriginURL.t.Errorf("ShortURLsMock.GetByOriginURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOriginURL.GetByOriginURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOriginURL.t.Fatal("No results are set for the ShortURLsMock.GetByOriginURL")
		}
		return (*mm_results).shortURL, (*mm_results).err
	}
	if mmGetByOriginURL.funcGetByOriginURL != nil {
		return mmGetByOriginURL.funcGetByOriginURL(ctx, originURL)
	}
	mmGetByOriginURL.t.Fatalf("Unexpected call to ShortURLsMock.GetByOriginURL. %v %v", ctx, originURL)
	return
}

// GetByOriginURLAfterCounter returns a count of finished ShortURLsMock.GetByOriginURL invocations
func (mmGetByOriginURL *ShortURLsMock) GetByOriginURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOriginURL.afterGetByOriginURLCounter)
}

// GetByOriginURLBeforeCounter returns a count of ShortURLsMock.GetByOriginURL invocations
func (mmGetByOriginURL *ShortURLsMock) GetByOriginURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOriginURL.beforeGetByOriginURLCounter)
}

// Calls returns a list of arguments used in each call to ShortURLsMock.GetByOriginURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOriginURL *mShortURLsMockGetByOriginURL) Calls() []*ShortURLsMockGetByOriginURLParams {
	mmGetByOriginURL.mutex.RLock()

	argCopy := make([]*ShortURLsMockGetByOriginURLParams, len(mmGetByOriginURL.callArgs))
	copy(argCopy, mmGetByOriginURL.callArgs)

	mmGetByOriginURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOriginURLDone returns true if the count of the GetByOriginURL invocations corresponds
// the number of defined expectations
func (m *ShortURLsMock) MinimockGetByOriginURLDone() bool {
	for _, e := range m.GetByOriginURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOriginURLMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByOriginURLCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOriginURL != nil && mm_atomic.LoadUint64(&m.afterGetByOriginURLCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByOriginURLInspect logs each unmet expectation
func (m *ShortURLsMock) MinimockGetByOriginURLInspect() {
	for _, e := range m.GetByOriginURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShortURLsMock.GetByOriginURL with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOriginURLMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByOriginURLCounter) < 1 {
		if m.GetByOriginURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShortURLsMock.GetByOriginURL")
		} else {
			m.t.Errorf("Expected call to ShortURLsMock.GetByOriginURL with params: %#v", *m.GetByOriginURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOriginURL != nil && mm_atomic.LoadUint64(&m.afterGetByOriginURLCounter) < 1 {
		m.t.Error("Expected call to ShortURLsMock.GetByOriginURL")
	}
}

type mShortURLsMockGetOriginURLByShortPath struct {
	mock               *ShortURLsMock
	defaultExpectation *ShortURLsMockGetOriginURLByShortPathExpectation
	expectations       []*ShortURLsMockGetOriginURLByShortPathExpectation

	callArgs []*ShortURLsMockGetOriginURLByShortPathParams
	mutex    sync.RWMutex
}

// ShortURLsMockGetOriginURLByShortPathExpectation specifies expectation struct of the ShortURLs.GetOriginURLByShortPath
type ShortURLsMockGetOriginURLByShortPathExpectation struct {
	mock    *ShortURLsMock
	params  *ShortURLsMockGetOriginURLByShortPathParams
	results *ShortURLsMockGetOriginURLByShortPathResults
	Counter uint64
}

// ShortURLsMockGetOriginURLByShortPathParams contains parameters of the ShortURLs.GetOriginURLByShortPath
type ShortURLsMockGetOriginURLByShortPathParams struct {
	ctx          context.Context
	shortURLPath string
}

// ShortURLsMockGetOriginURLByShortPathResults contains results of the ShortURLs.GetOriginURLByShortPath
type ShortURLsMockGetOriginURLByShortPathResults struct {
	originURL string
	err       error
}

// Expect sets up expected params for ShortURLs.GetOriginURLByShortPath
func (mmGetOriginURLByShortPath *mShortURLsMockGetOriginURLByShortPath) Expect(ctx context.Context, shortURLPath string) *mShortURLsMockGetOriginURLByShortPath {
	if mmGetOriginURLByShortPath.mock.funcGetOriginURLByShortPath != nil {
		mmGetOriginURLByShortPath.mock.t.Fatalf("ShortURLsMock.GetOriginURLByShortPath mock is already set by Set")
	}

	if mmGetOriginURLByShortPath.defaultExpectation == nil {
		mmGetOriginURLByShortPath.defaultExpectation = &ShortURLsMockGetOriginURLByShortPathExpectation{}
	}

	mmGetOriginURLByShortPath.defaultExpectation.params = &ShortURLsMockGetOriginURLByShortPathParams{ctx, shortURLPath}
	for _, e := range mmGetOriginURLByShortPath.expectations {
		if minimock.Equal(e.params, mmGetOriginURLByShortPath.defaultExpectation.params) {
			mmGetOriginURLByShortPath.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOriginURLByShortPath.defaultExpectation.params)
		}
	}

	return mmGetOriginURLByShortPath
}

// Inspect accepts an inspector function that has same arguments as the ShortURLs.GetOriginURLByShortPath
func (mmGetOriginURLByShortPath *mShortURLsMockGetOriginURLByShortPath) Inspect(f func(ctx context.Context, shortURLPath string)) *mShortURLsMockGetOriginURLByShortPath {
	if mmGetOriginURLByShortPath.mock.inspectFuncGetOriginURLByShortPath != nil {
		mmGetOriginURLByShortPath.mock.t.Fatalf("Inspect function is already set for ShortURLsMock.GetOriginURLByShortPath")
	}

	mmGetOriginURLByShortPath.mock.inspectFuncGetOriginURLByShortPath = f

	return mmGetOriginURLByShortPath
}

// Return sets up results that will be returned by ShortURLs.GetOriginURLByShortPath
func (mmGetOriginURLByShortPath *mShortURLsMockGetOriginURLByShortPath) Return(originURL string, err error) *ShortURLsMock {
	if mmGetOriginURLByShortPath.mock.funcGetOriginURLByShortPath != nil {
		mmGetOriginURLByShortPath.mock.t.Fatalf("ShortURLsMock.GetOriginURLByShortPath mock is already set by Set")
	}

	if mmGetOriginURLByShortPath.defaultExpectation == nil {
		mmGetOriginURLByShortPath.defaultExpectation = &ShortURLsMockGetOriginURLByShortPathExpectation{mock: mmGetOriginURLByShortPath.mock}
	}
	mmGetOriginURLByShortPath.defaultExpectation.results = &ShortURLsMockGetOriginURLByShortPathResults{originURL, err}
	return mmGetOriginURLByShortPath.mock
}

//Set uses given function f to mock the ShortURLs.GetOriginURLByShortPath method
func (mmGetOriginURLByShortPath *mShortURLsMockGetOriginURLByShortPath) Set(f func(ctx context.Context, shortURLPath string) (originURL string, err error)) *ShortURLsMock {
	if mmGetOriginURLByShortPath.defaultExpectation != nil {
		mmGetOriginURLByShortPath.mock.t.Fatalf("Default expectation is already set for the ShortURLs.GetOriginURLByShortPath method")
	}

	if len(mmGetOriginURLByShortPath.expectations) > 0 {
		mmGetOriginURLByShortPath.mock.t.Fatalf("Some expectations are already set for the ShortURLs.GetOriginURLByShortPath method")
	}

	mmGetOriginURLByShortPath.mock.funcGetOriginURLByShortPath = f
	return mmGetOriginURLByShortPath.mock
}

// When sets expectation for the ShortURLs.GetOriginURLByShortPath which will trigger the result defined by the following
// Then helper
func (mmGetOriginURLByShortPath *mShortURLsMockGetOriginURLByShortPath) When(ctx context.Context, shortURLPath string) *ShortURLsMockGetOriginURLByShortPathExpectation {
	if mmGetOriginURLByShortPath.mock.funcGetOriginURLByShortPath != nil {
		mmGetOriginURLByShortPath.mock.t.Fatalf("ShortURLsMock.GetOriginURLByShortPath mock is already set by Set")
	}

	expectation := &ShortURLsMockGetOriginURLByShortPathExpectation{
		mock:   mmGetOriginURLByShortPath.mock,
		params: &ShortURLsMockGetOriginURLByShortPathParams{ctx, shortURLPath},
	}
	mmGetOriginURLByShortPath.expectations = append(mmGetOriginURLByShortPath.expectations, expectation)
	return expectation
}

// Then sets up ShortURLs.GetOriginURLByShortPath return parameters for the expectation previously defined by the When method
func (e *ShortURLsMockGetOriginURLByShortPathExpectation) Then(originURL string, err error) *ShortURLsMock {
	e.results = &ShortURLsMockGetOriginURLByShortPathResults{originURL, err}
	return e.mock
}

// GetOriginURLByShortPath implements ShortURLs
func (mmGetOriginURLByShortPath *ShortURLsMock) GetOriginURLByShortPath(ctx context.Context, shortURLPath string) (originURL string, err error) {
	mm_atomic.AddUint64(&mmGetOriginURLByShortPath.beforeGetOriginURLByShortPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOriginURLByShortPath.afterGetOriginURLByShortPathCounter, 1)

	if mmGetOriginURLByShortPath.inspectFuncGetOriginURLByShortPath != nil {
		mmGetOriginURLByShortPath.inspectFuncGetOriginURLByShortPath(ctx, shortURLPath)
	}

	mm_params := &ShortURLsMockGetOriginURLByShortPathParams{ctx, shortURLPath}

	// Record call args
	mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.mutex.Lock()
	mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.callArgs = append(mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.callArgs, mm_params)
	mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.mutex.Unlock()

	for _, e := range mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.originURL, e.results.err
		}
	}

	if mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.defaultExpectation.params
		mm_got := ShortURLsMockGetOriginURLByShortPathParams{ctx, shortURLPath}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOriginURLByShortPath.t.Errorf("ShortURLsMock.GetOriginURLByShortPath got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOriginURLByShortPath.GetOriginURLByShortPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOriginURLByShortPath.t.Fatal("No results are set for the ShortURLsMock.GetOriginURLByShortPath")
		}
		return (*mm_results).originURL, (*mm_results).err
	}
	if mmGetOriginURLByShortPath.funcGetOriginURLByShortPath != nil {
		return mmGetOriginURLByShortPath.funcGetOriginURLByShortPath(ctx, shortURLPath)
	}
	mmGetOriginURLByShortPath.t.Fatalf("Unexpected call to ShortURLsMock.GetOriginURLByShortPath. %v %v", ctx, shortURLPath)
	return
}

// GetOriginURLByShortPathAfterCounter returns a count of finished ShortURLsMock.GetOriginURLByShortPath invocations
func (mmGetOriginURLByShortPath *ShortURLsMock) GetOriginURLByShortPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOriginURLByShortPath.afterGetOriginURLByShortPathCounter)
}

// GetOriginURLByShortPathBeforeCounter returns a count of ShortURLsMock.GetOriginURLByShortPath invocations
func (mmGetOriginURLByShortPath *ShortURLsMock) GetOriginURLByShortPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOriginURLByShortPath.beforeGetOriginURLByShortPathCounter)
}

// Calls returns a list of arguments used in each call to ShortURLsMock.GetOriginURLByShortPath.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOriginURLByShortPath *mShortURLsMockGetOriginURLByShortPath) Calls() []*ShortURLsMockGetOriginURLByShortPathParams {
	mmGetOriginURLByShortPath.mutex.RLock()

	argCopy := make([]*ShortURLsMockGetOriginURLByShortPathParams, len(mmGetOriginURLByShortPath.callArgs))
	copy(argCopy, mmGetOriginURLByShortPath.callArgs)

	mmGetOriginURLByShortPath.mutex.RUnlock()

	return argCopy
}

// MinimockGetOriginURLByShortPathDone returns true if the count of the GetOriginURLByShortPath invocations corresponds
// the number of defined expectations
func (m *ShortURLsMock) MinimockGetOriginURLByShortPathDone() bool {
	for _, e := range m.GetOriginURLByShortPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOriginURLByShortPathMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOriginURLByShortPathCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOriginURLByShortPath != nil && mm_atomic.LoadUint64(&m.afterGetOriginURLByShortPathCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOriginURLByShortPathInspect logs each unmet expectation
func (m *ShortURLsMock) MinimockGetOriginURLByShortPathInspect() {
	for _, e := range m.GetOriginURLByShortPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShortURLsMock.GetOriginURLByShortPath with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOriginURLByShortPathMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOriginURLByShortPathCounter) < 1 {
		if m.GetOriginURLByShortPathMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShortURLsMock.GetOriginURLByShortPath")
		} else {
			m.t.Errorf("Expected call to ShortURLsMock.GetOriginURLByShortPath with params: %#v", *m.GetOriginURLByShortPathMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOriginURLByShortPath != nil && mm_atomic.LoadUint64(&m.afterGetOriginURLByShortPathCounter) < 1 {
		m.t.Error("Expected call to ShortURLsMock.GetOriginURLByShortPath")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ShortURLsMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockDeleteByOriginURLInspect()

		m.MinimockGetByOriginURLInspect()

		m.MinimockGetOriginURLByShortPathInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ShortURLsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ShortURLsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteByOriginURLDone() &&
		m.MinimockGetByOriginURLDone() &&
		m.MinimockGetOriginURLByShortPathDone()
}
