package database

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// URLStorageMock implements URLStorage
type URLStorageMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, url string) (u1 uint64, err error)
	inspectFuncCreate   func(ctx context.Context, url string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mURLStorageMockCreate

	funcDelete          func(ctx context.Context, url string) (err error)
	inspectFuncDelete   func(ctx context.Context, url string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mURLStorageMockDelete

	funcDeleteByID          func(ctx context.Context, id uint64) (err error)
	inspectFuncDeleteByID   func(ctx context.Context, id uint64)
	afterDeleteByIDCounter  uint64
	beforeDeleteByIDCounter uint64
	DeleteByIDMock          mURLStorageMockDeleteByID

	funcFind          func(ctx context.Context, url string) (u1 uint64, err error)
	inspectFuncFind   func(ctx context.Context, url string)
	afterFindCounter  uint64
	beforeFindCounter uint64
	FindMock          mURLStorageMockFind

	funcGet          func(ctx context.Context, id uint64) (s1 string, err error)
	inspectFuncGet   func(ctx context.Context, id uint64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mURLStorageMockGet
}

// NewURLStorageMock returns a mock for URLStorage
func NewURLStorageMock(t minimock.Tester) *URLStorageMock {
	m := &URLStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mURLStorageMockCreate{mock: m}
	m.CreateMock.callArgs = []*URLStorageMockCreateParams{}

	m.DeleteMock = mURLStorageMockDelete{mock: m}
	m.DeleteMock.callArgs = []*URLStorageMockDeleteParams{}

	m.DeleteByIDMock = mURLStorageMockDeleteByID{mock: m}
	m.DeleteByIDMock.callArgs = []*URLStorageMockDeleteByIDParams{}

	m.FindMock = mURLStorageMockFind{mock: m}
	m.FindMock.callArgs = []*URLStorageMockFindParams{}

	m.GetMock = mURLStorageMockGet{mock: m}
	m.GetMock.callArgs = []*URLStorageMockGetParams{}

	return m
}

type mURLStorageMockCreate struct {
	mock               *URLStorageMock
	defaultExpectation *URLStorageMockCreateExpectation
	expectations       []*URLStorageMockCreateExpectation

	callArgs []*URLStorageMockCreateParams
	mutex    sync.RWMutex
}

// URLStorageMockCreateExpectation specifies expectation struct of the URLStorage.Create
type URLStorageMockCreateExpectation struct {
	mock    *URLStorageMock
	params  *URLStorageMockCreateParams
	results *URLStorageMockCreateResults
	Counter uint64
}

// URLStorageMockCreateParams contains parameters of the URLStorage.Create
type URLStorageMockCreateParams struct {
	ctx context.Context
	url string
}

// URLStorageMockCreateResults contains results of the URLStorage.Create
type URLStorageMockCreateResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for URLStorage.Create
func (mmCreate *mURLStorageMockCreate) Expect(ctx context.Context, url string) *mURLStorageMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("URLStorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &URLStorageMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &URLStorageMockCreateParams{ctx, url}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the URLStorage.Create
func (mmCreate *mURLStorageMockCreate) Inspect(f func(ctx context.Context, url string)) *mURLStorageMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for URLStorageMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by URLStorage.Create
func (mmCreate *mURLStorageMockCreate) Return(u1 uint64, err error) *URLStorageMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("URLStorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &URLStorageMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &URLStorageMockCreateResults{u1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the URLStorage.Create method
func (mmCreate *mURLStorageMockCreate) Set(f func(ctx context.Context, url string) (u1 uint64, err error)) *URLStorageMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the URLStorage.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the URLStorage.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the URLStorage.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mURLStorageMockCreate) When(ctx context.Context, url string) *URLStorageMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("URLStorageMock.Create mock is already set by Set")
	}

	expectation := &URLStorageMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &URLStorageMockCreateParams{ctx, url},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up URLStorage.Create return parameters for the expectation previously defined by the When method
func (e *URLStorageMockCreateExpectation) Then(u1 uint64, err error) *URLStorageMock {
	e.results = &URLStorageMockCreateResults{u1, err}
	return e.mock
}

// Create implements URLStorage
func (mmCreate *URLStorageMock) Create(ctx context.Context, url string) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, url)
	}

	mm_params := &URLStorageMockCreateParams{ctx, url}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := URLStorageMockCreateParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("URLStorageMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the URLStorageMock.Create")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, url)
	}
	mmCreate.t.Fatalf("Unexpected call to URLStorageMock.Create. %v %v", ctx, url)
	return
}

// CreateAfterCounter returns a count of finished URLStorageMock.Create invocations
func (mmCreate *URLStorageMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of URLStorageMock.Create invocations
func (mmCreate *URLStorageMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to URLStorageMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mURLStorageMockCreate) Calls() []*URLStorageMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*URLStorageMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *URLStorageMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *URLStorageMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLStorageMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLStorageMock.Create")
		} else {
			m.t.Errorf("Expected call to URLStorageMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to URLStorageMock.Create")
	}
}

type mURLStorageMockDelete struct {
	mock               *URLStorageMock
	defaultExpectation *URLStorageMockDeleteExpectation
	expectations       []*URLStorageMockDeleteExpectation

	callArgs []*URLStorageMockDeleteParams
	mutex    sync.RWMutex
}

// URLStorageMockDeleteExpectation specifies expectation struct of the URLStorage.Delete
type URLStorageMockDeleteExpectation struct {
	mock    *URLStorageMock
	params  *URLStorageMockDeleteParams
	results *URLStorageMockDeleteResults
	Counter uint64
}

// URLStorageMockDeleteParams contains parameters of the URLStorage.Delete
type URLStorageMockDeleteParams struct {
	ctx context.Context
	url string
}

// URLStorageMockDeleteResults contains results of the URLStorage.Delete
type URLStorageMockDeleteResults struct {
	err error
}

// Expect sets up expected params for URLStorage.Delete
func (mmDelete *mURLStorageMockDelete) Expect(ctx context.Context, url string) *mURLStorageMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("URLStorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &URLStorageMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &URLStorageMockDeleteParams{ctx, url}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the URLStorage.Delete
func (mmDelete *mURLStorageMockDelete) Inspect(f func(ctx context.Context, url string)) *mURLStorageMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for URLStorageMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by URLStorage.Delete
func (mmDelete *mURLStorageMockDelete) Return(err error) *URLStorageMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("URLStorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &URLStorageMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &URLStorageMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the URLStorage.Delete method
func (mmDelete *mURLStorageMockDelete) Set(f func(ctx context.Context, url string) (err error)) *URLStorageMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the URLStorage.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the URLStorage.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the URLStorage.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mURLStorageMockDelete) When(ctx context.Context, url string) *URLStorageMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("URLStorageMock.Delete mock is already set by Set")
	}

	expectation := &URLStorageMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &URLStorageMockDeleteParams{ctx, url},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up URLStorage.Delete return parameters for the expectation previously defined by the When method
func (e *URLStorageMockDeleteExpectation) Then(err error) *URLStorageMock {
	e.results = &URLStorageMockDeleteResults{err}
	return e.mock
}

// Delete implements URLStorage
func (mmDelete *URLStorageMock) Delete(ctx context.Context, url string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, url)
	}

	mm_params := &URLStorageMockDeleteParams{ctx, url}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := URLStorageMockDeleteParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("URLStorageMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the URLStorageMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, url)
	}
	mmDelete.t.Fatalf("Unexpected call to URLStorageMock.Delete. %v %v", ctx, url)
	return
}

// DeleteAfterCounter returns a count of finished URLStorageMock.Delete invocations
func (mmDelete *URLStorageMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of URLStorageMock.Delete invocations
func (mmDelete *URLStorageMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to URLStorageMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mURLStorageMockDelete) Calls() []*URLStorageMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*URLStorageMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *URLStorageMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *URLStorageMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLStorageMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLStorageMock.Delete")
		} else {
			m.t.Errorf("Expected call to URLStorageMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to URLStorageMock.Delete")
	}
}

type mURLStorageMockDeleteByID struct {
	mock               *URLStorageMock
	defaultExpectation *URLStorageMockDeleteByIDExpectation
	expectations       []*URLStorageMockDeleteByIDExpectation

	callArgs []*URLStorageMockDeleteByIDParams
	mutex    sync.RWMutex
}

// URLStorageMockDeleteByIDExpectation specifies expectation struct of the URLStorage.DeleteByID
type URLStorageMockDeleteByIDExpectation struct {
	mock    *URLStorageMock
	params  *URLStorageMockDeleteByIDParams
	results *URLStorageMockDeleteByIDResults
	Counter uint64
}

// URLStorageMockDeleteByIDParams contains parameters of the URLStorage.DeleteByID
type URLStorageMockDeleteByIDParams struct {
	ctx context.Context
	id  uint64
}

// URLStorageMockDeleteByIDResults contains results of the URLStorage.DeleteByID
type URLStorageMockDeleteByIDResults struct {
	err error
}

// Expect sets up expected params for URLStorage.DeleteByID
func (mmDeleteByID *mURLStorageMockDeleteByID) Expect(ctx context.Context, id uint64) *mURLStorageMockDeleteByID {
	if mmDeleteByID.mock.funcDeleteByID != nil {
		mmDeleteByID.mock.t.Fatalf("URLStorageMock.DeleteByID mock is already set by Set")
	}

	if mmDeleteByID.defaultExpectation == nil {
		mmDeleteByID.defaultExpectation = &URLStorageMockDeleteByIDExpectation{}
	}

	mmDeleteByID.defaultExpectation.params = &URLStorageMockDeleteByIDParams{ctx, id}
	for _, e := range mmDeleteByID.expectations {
		if minimock.Equal(e.params, mmDeleteByID.defaultExpectation.params) {
			mmDeleteByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteByID.defaultExpectation.params)
		}
	}

	return mmDeleteByID
}

// Inspect accepts an inspector function that has same arguments as the URLStorage.DeleteByID
func (mmDeleteByID *mURLStorageMockDeleteByID) Inspect(f func(ctx context.Context, id uint64)) *mURLStorageMockDeleteByID {
	if mmDeleteByID.mock.inspectFuncDeleteByID != nil {
		mmDeleteByID.mock.t.Fatalf("Inspect function is already set for URLStorageMock.DeleteByID")
	}

	mmDeleteByID.mock.inspectFuncDeleteByID = f

	return mmDeleteByID
}

// Return sets up results that will be returned by URLStorage.DeleteByID
func (mmDeleteByID *mURLStorageMockDeleteByID) Return(err error) *URLStorageMock {
	if mmDeleteByID.mock.funcDeleteByID != nil {
		mmDeleteByID.mock.t.Fatalf("URLStorageMock.DeleteByID mock is already set by Set")
	}

	if mmDeleteByID.defaultExpectation == nil {
		mmDeleteByID.defaultExpectation = &URLStorageMockDeleteByIDExpectation{mock: mmDeleteByID.mock}
	}
	mmDeleteByID.defaultExpectation.results = &URLStorageMockDeleteByIDResults{err}
	return mmDeleteByID.mock
}

//Set uses given function f to mock the URLStorage.DeleteByID method
func (mmDeleteByID *mURLStorageMockDeleteByID) Set(f func(ctx context.Context, id uint64) (err error)) *URLStorageMock {
	if mmDeleteByID.defaultExpectation != nil {
		mmDeleteByID.mock.t.Fatalf("Default expectation is already set for the URLStorage.DeleteByID method")
	}

	if len(mmDeleteByID.expectations) > 0 {
		mmDeleteByID.mock.t.Fatalf("Some expectations are already set for the URLStorage.DeleteByID method")
	}

	mmDeleteByID.mock.funcDeleteByID = f
	return mmDeleteByID.mock
}

// When sets expectation for the URLStorage.DeleteByID which will trigger the result defined by the following
// Then helper
func (mmDeleteByID *mURLStorageMockDeleteByID) When(ctx context.Context, id uint64) *URLStorageMockDeleteByIDExpectation {
	if mmDeleteByID.mock.funcDeleteByID != nil {
		mmDeleteByID.mock.t.Fatalf("URLStorageMock.DeleteByID mock is already set by Set")
	}

	expectation := &URLStorageMockDeleteByIDExpectation{
		mock:   mmDeleteByID.mock,
		params: &URLStorageMockDeleteByIDParams{ctx, id},
	}
	mmDeleteByID.expectations = append(mmDeleteByID.expectations, expectation)
	return expectation
}

// Then sets up URLStorage.DeleteByID return parameters for the expectation previously defined by the When method
func (e *URLStorageMockDeleteByIDExpectation) Then(err error) *URLStorageMock {
	e.results = &URLStorageMockDeleteByIDResults{err}
	return e.mock
}

// DeleteByID implements URLStorage
func (mmDeleteByID *URLStorageMock) DeleteByID(ctx context.Context, id uint64) (err error) {
	mm_atomic.AddUint64(&mmDeleteByID.beforeDeleteByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteByID.afterDeleteByIDCounter, 1)

	if mmDeleteByID.inspectFuncDeleteByID != nil {
		mmDeleteByID.inspectFuncDeleteByID(ctx, id)
	}

	mm_params := &URLStorageMockDeleteByIDParams{ctx, id}

	// Record call args
	mmDeleteByID.DeleteByIDMock.mutex.Lock()
	mmDeleteByID.DeleteByIDMock.callArgs = append(mmDeleteByID.DeleteByIDMock.callArgs, mm_params)
	mmDeleteByID.DeleteByIDMock.mutex.Unlock()

	for _, e := range mmDeleteByID.DeleteByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteByID.DeleteByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteByID.DeleteByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteByID.DeleteByIDMock.defaultExpectation.params
		mm_got := URLStorageMockDeleteByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteByID.t.Errorf("URLStorageMock.DeleteByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteByID.DeleteByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteByID.t.Fatal("No results are set for the URLStorageMock.DeleteByID")
		}
		return (*mm_results).err
	}
	if mmDeleteByID.funcDeleteByID != nil {
		return mmDeleteByID.funcDeleteByID(ctx, id)
	}
	mmDeleteByID.t.Fatalf("Unexpected call to URLStorageMock.DeleteByID. %v %v", ctx, id)
	return
}

// DeleteByIDAfterCounter returns a count of finished URLStorageMock.DeleteByID invocations
func (mmDeleteByID *URLStorageMock) DeleteByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByID.afterDeleteByIDCounter)
}

// DeleteByIDBeforeCounter returns a count of URLStorageMock.DeleteByID invocations
func (mmDeleteByID *URLStorageMock) DeleteByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByID.beforeDeleteByIDCounter)
}

// Calls returns a list of arguments used in each call to URLStorageMock.DeleteByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteByID *mURLStorageMockDeleteByID) Calls() []*URLStorageMockDeleteByIDParams {
	mmDeleteByID.mutex.RLock()

	argCopy := make([]*URLStorageMockDeleteByIDParams, len(mmDeleteByID.callArgs))
	copy(argCopy, mmDeleteByID.callArgs)

	mmDeleteByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteByIDDone returns true if the count of the DeleteByID invocations corresponds
// the number of defined expectations
func (m *URLStorageMock) MinimockDeleteByIDDone() bool {
	for _, e := range m.DeleteByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByID != nil && mm_atomic.LoadUint64(&m.afterDeleteByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteByIDInspect logs each unmet expectation
func (m *URLStorageMock) MinimockDeleteByIDInspect() {
	for _, e := range m.DeleteByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLStorageMock.DeleteByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByIDCounter) < 1 {
		if m.DeleteByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLStorageMock.DeleteByID")
		} else {
			m.t.Errorf("Expected call to URLStorageMock.DeleteByID with params: %#v", *m.DeleteByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByID != nil && mm_atomic.LoadUint64(&m.afterDeleteByIDCounter) < 1 {
		m.t.Error("Expected call to URLStorageMock.DeleteByID")
	}
}

type mURLStorageMockFind struct {
	mock               *URLStorageMock
	defaultExpectation *URLStorageMockFindExpectation
	expectations       []*URLStorageMockFindExpectation

	callArgs []*URLStorageMockFindParams
	mutex    sync.RWMutex
}

// URLStorageMockFindExpectation specifies expectation struct of the URLStorage.Find
type URLStorageMockFindExpectation struct {
	mock    *URLStorageMock
	params  *URLStorageMockFindParams
	results *URLStorageMockFindResults
	Counter uint64
}

// URLStorageMockFindParams contains parameters of the URLStorage.Find
type URLStorageMockFindParams struct {
	ctx context.Context
	url string
}

// URLStorageMockFindResults contains results of the URLStorage.Find
type URLStorageMockFindResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for URLStorage.Find
func (mmFind *mURLStorageMockFind) Expect(ctx context.Context, url string) *mURLStorageMockFind {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("URLStorageMock.Find mock is already set by Set")
	}

	if mmFind.defaultExpectation == nil {
		mmFind.defaultExpectation = &URLStorageMockFindExpectation{}
	}

	mmFind.defaultExpectation.params = &URLStorageMockFindParams{ctx, url}
	for _, e := range mmFind.expectations {
		if minimock.Equal(e.params, mmFind.defaultExpectation.params) {
			mmFind.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFind.defaultExpectation.params)
		}
	}

	return mmFind
}

// Inspect accepts an inspector function that has same arguments as the URLStorage.Find
func (mmFind *mURLStorageMockFind) Inspect(f func(ctx context.Context, url string)) *mURLStorageMockFind {
	if mmFind.mock.inspectFuncFind != nil {
		mmFind.mock.t.Fatalf("Inspect function is already set for URLStorageMock.Find")
	}

	mmFind.mock.inspectFuncFind = f

	return mmFind
}

// Return sets up results that will be returned by URLStorage.Find
func (mmFind *mURLStorageMockFind) Return(u1 uint64, err error) *URLStorageMock {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("URLStorageMock.Find mock is already set by Set")
	}

	if mmFind.defaultExpectation == nil {
		mmFind.defaultExpectation = &URLStorageMockFindExpectation{mock: mmFind.mock}
	}
	mmFind.defaultExpectation.results = &URLStorageMockFindResults{u1, err}
	return mmFind.mock
}

//Set uses given function f to mock the URLStorage.Find method
func (mmFind *mURLStorageMockFind) Set(f func(ctx context.Context, url string) (u1 uint64, err error)) *URLStorageMock {
	if mmFind.defaultExpectation != nil {
		mmFind.mock.t.Fatalf("Default expectation is already set for the URLStorage.Find method")
	}

	if len(mmFind.expectations) > 0 {
		mmFind.mock.t.Fatalf("Some expectations are already set for the URLStorage.Find method")
	}

	mmFind.mock.funcFind = f
	return mmFind.mock
}

// When sets expectation for the URLStorage.Find which will trigger the result defined by the following
// Then helper
func (mmFind *mURLStorageMockFind) When(ctx context.Context, url string) *URLStorageMockFindExpectation {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("URLStorageMock.Find mock is already set by Set")
	}

	expectation := &URLStorageMockFindExpectation{
		mock:   mmFind.mock,
		params: &URLStorageMockFindParams{ctx, url},
	}
	mmFind.expectations = append(mmFind.expectations, expectation)
	return expectation
}

// Then sets up URLStorage.Find return parameters for the expectation previously defined by the When method
func (e *URLStorageMockFindExpectation) Then(u1 uint64, err error) *URLStorageMock {
	e.results = &URLStorageMockFindResults{u1, err}
	return e.mock
}

// Find implements URLStorage
func (mmFind *URLStorageMock) Find(ctx context.Context, url string) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmFind.beforeFindCounter, 1)
	defer mm_atomic.AddUint64(&mmFind.afterFindCounter, 1)

	if mmFind.inspectFuncFind != nil {
		mmFind.inspectFuncFind(ctx, url)
	}

	mm_params := &URLStorageMockFindParams{ctx, url}

	// Record call args
	mmFind.FindMock.mutex.Lock()
	mmFind.FindMock.callArgs = append(mmFind.FindMock.callArgs, mm_params)
	mmFind.FindMock.mutex.Unlock()

	for _, e := range mmFind.FindMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmFind.FindMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFind.FindMock.defaultExpectation.Counter, 1)
		mm_want := mmFind.FindMock.defaultExpectation.params
		mm_got := URLStorageMockFindParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFind.t.Errorf("URLStorageMock.Find got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFind.FindMock.defaultExpectation.results
		if mm_results == nil {
			mmFind.t.Fatal("No results are set for the URLStorageMock.Find")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmFind.funcFind != nil {
		return mmFind.funcFind(ctx, url)
	}
	mmFind.t.Fatalf("Unexpected call to URLStorageMock.Find. %v %v", ctx, url)
	return
}

// FindAfterCounter returns a count of finished URLStorageMock.Find invocations
func (mmFind *URLStorageMock) FindAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFind.afterFindCounter)
}

// FindBeforeCounter returns a count of URLStorageMock.Find invocations
func (mmFind *URLStorageMock) FindBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFind.beforeFindCounter)
}

// Calls returns a list of arguments used in each call to URLStorageMock.Find.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFind *mURLStorageMockFind) Calls() []*URLStorageMockFindParams {
	mmFind.mutex.RLock()

	argCopy := make([]*URLStorageMockFindParams, len(mmFind.callArgs))
	copy(argCopy, mmFind.callArgs)

	mmFind.mutex.RUnlock()

	return argCopy
}

// MinimockFindDone returns true if the count of the Find invocations corresponds
// the number of defined expectations
func (m *URLStorageMock) MinimockFindDone() bool {
	for _, e := range m.FindMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFind != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindInspect logs each unmet expectation
func (m *URLStorageMock) MinimockFindInspect() {
	for _, e := range m.FindMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLStorageMock.Find with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		if m.FindMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLStorageMock.Find")
		} else {
			m.t.Errorf("Expected call to URLStorageMock.Find with params: %#v", *m.FindMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFind != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		m.t.Error("Expected call to URLStorageMock.Find")
	}
}

type mURLStorageMockGet struct {
	mock               *URLStorageMock
	defaultExpectation *URLStorageMockGetExpectation
	expectations       []*URLStorageMockGetExpectation

	callArgs []*URLStorageMockGetParams
	mutex    sync.RWMutex
}

// URLStorageMockGetExpectation specifies expectation struct of the URLStorage.Get
type URLStorageMockGetExpectation struct {
	mock    *URLStorageMock
	params  *URLStorageMockGetParams
	results *URLStorageMockGetResults
	Counter uint64
}

// URLStorageMockGetParams contains parameters of the URLStorage.Get
type URLStorageMockGetParams struct {
	ctx context.Context
	id  uint64
}

// URLStorageMockGetResults contains results of the URLStorage.Get
type URLStorageMockGetResults struct {
	s1  string
	err error
}

// Expect sets up expected params for URLStorage.Get
func (mmGet *mURLStorageMockGet) Expect(ctx context.Context, id uint64) *mURLStorageMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("URLStorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &URLStorageMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &URLStorageMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the URLStorage.Get
func (mmGet *mURLStorageMockGet) Inspect(f func(ctx context.Context, id uint64)) *mURLStorageMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for URLStorageMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by URLStorage.Get
func (mmGet *mURLStorageMockGet) Return(s1 string, err error) *URLStorageMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("URLStorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &URLStorageMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &URLStorageMockGetResults{s1, err}
	return mmGet.mock
}

//Set uses given function f to mock the URLStorage.Get method
func (mmGet *mURLStorageMockGet) Set(f func(ctx context.Context, id uint64) (s1 string, err error)) *URLStorageMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the URLStorage.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the URLStorage.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the URLStorage.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mURLStorageMockGet) When(ctx context.Context, id uint64) *URLStorageMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("URLStorageMock.Get mock is already set by Set")
	}

	expectation := &URLStorageMockGetExpectation{
		mock:   mmGet.mock,
		params: &URLStorageMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up URLStorage.Get return parameters for the expectation previously defined by the When method
func (e *URLStorageMockGetExpectation) Then(s1 string, err error) *URLStorageMock {
	e.results = &URLStorageMockGetResults{s1, err}
	return e.mock
}

// Get implements URLStorage
func (mmGet *URLStorageMock) Get(ctx context.Context, id uint64) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := &URLStorageMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := URLStorageMockGetParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("URLStorageMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the URLStorageMock.Get")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to URLStorageMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished URLStorageMock.Get invocations
func (mmGet *URLStorageMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of URLStorageMock.Get invocations
func (mmGet *URLStorageMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to URLStorageMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mURLStorageMockGet) Calls() []*URLStorageMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*URLStorageMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *URLStorageMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *URLStorageMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLStorageMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLStorageMock.Get")
		} else {
			m.t.Errorf("Expected call to URLStorageMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to URLStorageMock.Get")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *URLStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockDeleteByIDInspect()

		m.MinimockFindInspect()

		m.MinimockGetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *URLStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *URLStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteByIDDone() &&
		m.MinimockFindDone() &&
		m.MinimockGetDone()
}
